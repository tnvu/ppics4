# Review Questions

# True/False
# 1.    Information that is stored and manipulated by computers is
#       called data.                                                    True
# 2.    Since floating-point numbers are extremely accurate, they 
#       should generally be used instead of ints.                       False
# 3.    Operations like addition and subtraction are defined in 
#       the math library.                                               False
# 4.    The number of possible arrangements of n items is equal to n!.  True
# 5.    The sqrt function computes the squirt of a number.              False
# 6.    The float data type is identical to the mathematical concept 
#       of a real number.                                               False
# 7.    Computers represent numbers using base-2 (binary)
#       representations.                                                True
# 8.    A hardware float can represent a larger range of values than
#       a hardware int.                                                 True
# 9.    Computing int (10.5) is OK, but int ("10.5") produces an error. True
# 10.   In Python, 4 + 5 produces the same result type as 4.0 + 5.0.    False

# Multiple Choice
# 1.    Which of the following is not a built-in Python data type?
#       a) int
#       b) float
#     X c) rational
#       d) string
# 2.    Which of the following is not a built-in operation?
#       a) +
#       b) %
#       c) abs()
#     X d) sqrt()
# 3.    In order to use functions in the math library, a program must include
#       a) a comment
#       b) a loop
#       c) an operator
#     X d) an import statement
# 4.    The value of 4! is
#       a) 9
#     X b) 24
#       c) 41
#       d) 120
# 5.    The most appropriate data type for storing the value of pi is
#       a) int
#     X b) float
#       c) irrational
#       d) string
# 6.    The number of distinct values that can be represented using 5 bits is
#       a) 5
#       b) 10
#     X c) 32
#       d) 50
# 7.    In a mixed-type expression involving ints and floats, Python will convert
#       a) floats to ints
#       b) ints to strings
#       c) both floats and ints to strings
#     X d) ints to floats
# 8.    Which of the following is not a Python type-conversion function?
#       a) float
#       b) round
#       c) int
#     X d) abs
# 9.    The pattern used to compute factorials is
#     X a) accumulator
#       b) input, process, output
#       c) counted loop
#       d) plaid
# 10.   In modern Python, an int value that grows larger than the underlying
#       hardware int
#       a) causes an overflow
#       b) converts to float
#       c) breaks the computer
#     X d) uses more memory

# Discussion
# 1.    Show the result of evaluating each expression. Be sure that the value
#       is in the proper form to indicate its type (int or float). If the
#       expression is illegal, explain why.
#           a) 4.0 / 10.0 + 3.5 * 2             7.4
#           b) 10 % 4 + 6 / 2                   5.0
#           c) abs(4 - 20 // 3) ** 3            8
#           d) sqrt(4.5 - 5.0) + 7 * 3          Illegal, square root of <0
#           e) 3 * 10 // 3 + 10 % 3             11
#           f) 3 ** 3                           27
# 2.    Translate each of the following mathematical expressions into an
#       equivalent Python expression. You may assume that the math library
#       has been imported (via import math).
#       a) (3+4)(5)                             (3 + 4) * 5
#       b) n(n-1)/2                             n * (n - 1) / 2
#       c) 4(pi)r^2                             4 * math.pi * r**2
#       d) sqrt(r(cos a)^2 + r(sin b)^2)
#                                       sqrt(r * cos(a)**2 + r * sin(b)**2))
#       e) (y2 - y1)/(x2 - x1)                  (y2 - y1) / (x2 - x1)
# 3.    Show the sequence of numbers that would be generated by each of the
#       following range expressions.
#       a) range(5)                         [0, 1, 2, 3 , 4]
#       b) range(3, 10)                     [3, 4, 5, 6, 7, 8, 9]
#       c) range(4, 13, 3)                  [4, 7, 10]
#       d) range(15, 5, -2)                 [15, 13, 11, 9, 7]
#       e) range(5, 3)                      []
# 4.    Show the output that would be generated by each of the following 
#       program fragments.
#       a)  for i in range(1, 11):
#               print (i * i)
#           1
#           4
#           9
#           16
#           25
#           36
#           49
#           64
#           81
#           100
#       b)  for i in [1,3,5,7,9]:
#               print(i, ":", i**3)
#               print (i)
#           1 : 1
#           3 : 27
#           5 : 125
#           7 : 343
#           9 : 729
#       c)  x = 2
#           y = 10
#           for j in range(0, y, x):
#               print(j, end="")
#               print(x + y)
#           print("done")
#           012
#           212
#           412
#           612
#           812
#       d)  ans = 0
#           for i in range(1, 11):
#               ans = ans + i * i
#               print(i)
#           print (ans)
#           1
#           2
#           3
#           4
#           5
#           6
#           7
#           8
#           9
#           10
#           385
# 5.    What do you think will happen if you use a negative number as the
#       second parameter in the round function? For example, what should be 
#       the result of round(314.159265, -1)? Explain the rationale for your
#       answer. After you've written your answer, consult the Python
#       documentation or try out some examples to see what Python actually
#       does in this case.
#       If a negative number for the second paramter, round will error (?)
#       In actuality, Python rounds to the nearest 10**ndigits
# 6.    A new Python programmer wrote the following (incorrect) program to
#       compute factorials:
#          def main():
#               print("This program compute the factorial of a number.")
#               n = input("Enter a positive whole number: ")
#               for factor in range(2, n):
#                   fact = fact * factor
#              print("The factorial of", n, "is", fact)
#           main()
#       a)  When initially run, the program gave the following error:
#               ..., line 4, in main
#               for factor in range(2, n):
#               TypeError: 'str' object cannot be interpreted as an integer
#           How would you fix this error? Hint: Look at the input.
#               int(input(...))
#       b)  After fixing the first error, the program then produced this:
#               ..., line 5, in main
#               fact = fact * factor
#               UnboundLocalError: local variable 'fact' referenced before
#               assignment
#           How would you fix this error? (Hint: Part of the accumulator 
#           pattern is missing.)
#                fact = 1
#       c)  Now the program runs, but it gives the incorrect result that the
#           factorial of 5 is 24. A useful debugging technique is to get more 
#           information by adding print statements. The student added a print
#           statement inside the loop as follows:
#               for factor in range(2, n):
#                   print("factor =", factor)
#                   fact = fact * factor
#           What did the student now see printed when computing the factorial 
#           of 5?
#               2
#               3
#               4
#       d)  Using the information from part c, the student managed to fix the
#           program by adding two characters to the loop heading. What is the
#           fix?
#               for factor in range(2, n+1):